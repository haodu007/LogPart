

###########################################################################
# Module:   AddInt													                                 					
###########################################################################

AddInt  := module ()
  option package;
  description "The module includes functions for determining elementary integrals via additive decompositions";
  export
     AlgRaab,
     ConstantCoefficient,
     DifferentiateResidue,
     LocalResidue,
     LogTower,
     SPrimitiveTower;
  local
     IsSimple,
     IsSimple1,
     LogarithmicPartI ;


##########################################################################
# Name: IsSimple1
# Calling sequences:  IsSimple1(T, f, t)
# Input:  x, a variable;
#            T, a list of indeterminates;
#            f, an element in the S-primitive tower generated by T;
#            t, an element in T;
#Output: true if f is t-simple, Otherwise, false is returned.
##########################################################################

IsSimple1 :=  proc(T, f, t)
      local n, a, p, L, g, h, i;
      if f = 0 then
         return true;
      end if; 
      n  := nops(T);
      a  := member(t, T, 'p'); 
      if a = false then
         return false;
      end if;
      L := [seq(T[i], i=p+1..n)];
      if depends(f, L) then
         return false;
      end if;
      (g, h) := numer(f), denom(f);
      if degree(g,t) < degree(h,t) then
         if  degree(gcd(h, diff(h,t)), t)=0 then
             return true;
         end if;
      end if; 
      return false;
end proc; 
      
##########################################################################
# Name: IsSimple
# Calling sequences:  IsSimple(x, T,  f)
# Input:  x, a variable;
#            T, a list of indeterminates;
#            f, an element in the S-primitive tower generated by T in its matryoshka form;
#Output: true if f is simple, Otherwise, false is returned.
##########################################################################

IsSimple := proc(x, T, f)
   local n, TT, i, a;
   n := nops(T); 
   TT := [x, op(T)]; 
   for i from 1 to n+1 do 
        a := IsSimple1(TT, f[i],  TT[i]);
         if a = false then
            return false;
         end if;
    end do;
    return true;
end proc:

#######################################################################################################
# Name: LogTower
# Calling Sequence：LogTower(x, T, dT, f)
# Input:  x,   an indeterminate of the base field K_0 = C(x),
#         T = [t_1, t_2,..,t_n],   a list of logarithmic generators,
#         dT = [t1', t2', .., tn'],    the list of derivatives of T,
#         f,   a rational function in K_0(T).
#
# Output: false if the integral of f is not elementary of K0(T),  
#              the integral of f, otherwise
#######################################################################################################


LogTower   :=  proc(x, T, dT, f)
    local  ff,  H, g, R, n, L, i, r,  lp, _Z, TT;

    # -------------------------
    #  trivial case
    #--------------------------

    ff := normal(f); 
    if ff = 0 then
       return 0;
    end if; 

    #-----------------------------
    #  addtive decomposition
    #-----------------------------

    TT := time();

    H := AddDecomp:-SPrimitive(x, T, dT, ff);
    (g, R) := H[1], H[2]; 

    # print(time_taken_for_AddDecomp);  print(time()-TT); 

    #------------------------------
    # in-field integrable
    #------------------------------

    if {op(R)} = {0} then
       return g;
    end if;

    #------------------------------
    # the remainder is simple?
    #------------------------------

    if not IsSimple(x, T, R) then
       return false;
    end if;

    #------------------------------------------
    # determine complete logarithmic parts
    #------------------------------------------

    TT := time();

    n := nops(T);
    L := Array(0..n);
    L[0] := R[1]; 
    for i from 1 to n do
         r := R[i+1];
         if r = 0 then
            L[i] := 0;
         else
            L[i] := LogPart:-CompleteLogarithmicPart(x, [op(1..i, T)], [op(1..i, dT)],  r,  '_Z');
            if L[i] = false then return false; end if;
         end if;
    end do;

    #print(time_taken_for_RTs); print(time()-TT); 
    lp := int(L[0], x);
    for i from 1 to n do
         if L[i] <> 0 then
            lp := lp + LogarithmicPartI(L[i],  _Z);
         end if;
     end do;
     return g + lp;
end proc:


#######################################################################################################
# Name: SPrimitiveTower
# Calling Sequence：LogTower(x, T, dT, f)
# Input:  x,   an indeterminate of the base field K_0 = C(x),
#         T = [t_1, t_2,..,t_n],   a list of S-primitve generators,
#         dT = [t1', t2', .., tn'],    the list of derivatives of T,
#         f,   a rational function in K_0(T).
#
# Output: false if the integral of f is not elementary of K0(T),  
#              the integral of f, otherwise
#######################################################################################################


SPrimitiveTower   :=  proc(x, T, dT, f)
    local  ff,  H, g, R, n, integral, i, j, r,  s, lp, _Z, C, A, lt, h;

    # -------------------------
    #  trivial case
    #--------------------------

    ff := normal(f); 
    if ff = 0 then
       return 0;
    end if; 

    #-----------------------------
    #  addtive decomposition
    #-----------------------------

    H := AddDecomp:-SPrimitive(x, T, dT, ff);
    (g, R) := H[1], H[2]; 

    #------------------------------
    # in-field integrable
    #------------------------------

    if {op(R)} = {0} then
       return g;
    end if;

    #------------------------------
    # the remainder is simple?
    #------------------------------

    if not IsSimple(x, T, R) then
       return false;
    end if;

   #-----------------------------
   # Raab's algorithm
   #-----------------------------

   h  := ConstantCoefficient(x, T, dT, R, _Z);
   
   if  h = false then
       return false;
   end if;
   (C, lt) := h[1], h[2];

    #------------------------------------------
    # determine complete logarithmic parts
    #------------------------------------------

    n := nops(T); 
    A := DField:-AssociatedMatrix(T, dT); #print(A);
    integral := g+int(R[1]+add(C[j]*A[1,j], j=1..n), x) + LogarithmicPartI(lt,  _Z) ;
    
    for i from 1 to n-1 do
         r := R[i+1];
         s :=  normal(add(C[j]*A[i+1,j], j=1..n)); 
         r := normal(r - s);
         if r <> 0 then
            lp := LogPart:-LogarithmicPart(x, [op(1..i, T)], [op(1..i, dT)],  r,  '_Z')[1];
            #print(lp_is); print(lp);
            integral := integral +  LogarithmicPartI(lp,  _Z);
         end if;
    end do;
    return integral + add(C[j]*T[j], j=1..n); 
end proc:

#==================================================================================
#Name: LogarithmicPartI
#Calling sequence: 
#      LogarithmicPartI(L, _Z)
#Input:   L, a list of logarithmic derivatives in algebraic form
#            _Z, an indeterminate;
#Output: w, the integral of L 
#====================================================================================
 
LogarithmicPartI := proc(L, _Z)
      local m, w, i, p, g, _R, dz, k;
      if L = 0 then return 0;  end if;
      m := nops(L);
      #if m = 0 then
         #return 0;
      #end if;
      w := 0; 
      for i from 1 to m do 
            (p, g) := L[i][1], L[i][2];
            _R := RootOf(p=0, index = k);
            dz := degree(p, _Z);
             w  := w  + sum(_R*subs(_Z=_R, log(g)),  k=1..dz);
      end do;
      return w;
end proc;

################################################################################################
# Name:  AlgRaab
# Calling sequence: AlgRaab(x, T, dT, f, L)
# Input:   x,    a variable of the base field C(x);
#          T = [t1, t2, .., tn],    a list of indeterminates over the base field, T<>[];
#          dT = [t1', t2', .., tn'],   a list of derivatives of elements in T, maybe [];
#          f,   a tn-simple function in C(x, T);
#          L,   a list of t_n-simple function;
# Output:  [rn, cn, A, v], 
#                rn -- the number of rows of A,
#                cn -- the number of columns of A,
#                A,  a matrix over C,
#                v,  a vector in C^{rn}
#                such that  all the residues of f - c[1]*L[1] - ... - c[m]*L[m] are constants iff
#                          A(c[1], ..., c[m])^t = v'
############################################################################################### 

AlgRaab  := proc(x, T, dT, f, L)
     local m, c, g, r, S, i, j, k, H, rn, cn, A, v, s;
     m := nops(L);
     c := array(1..m);
     g := f - add(c[i]*L[i], i=1..m);

     if g = 0 then
        rn := 1; cn := m;
        A := Matrix(rn, cn);
        v := Matrix(rn, 1);
        return [rn, cn, A, v];
      end if; 

      r := numer(DifferentiateResidue(x, T, dT, g, denom(g)));
      S := [coeffs(r, {x, op(T)})];
      H := {seq(c[k]=0,k=1..m)}; 
      rn := nops(S);
      cn := m;
      A := Matrix(rn, cn);
      v := Matrix(rn, 1);
      for i from 1 to rn do
           s := S[i];
           v[i,1] := -normal(subs(H, s));
           for j from 1 to cn do
                A[i, j] := coeff(s, c[j], 1);
           end do;
      end do; 
      return [rn, cn, A, v];
end proc;

################################################################################################
# Name: DifferentiateResidue
# Calling sequence: DifferentiateResidue(x, T, dT, f, p)
# Input:   x,    a variable of the base field C(x);
#             T = [t1, t2, .., tn],    a list of indeterminates over the base field, maybe [];
#             dT = [t1', t2', .., tn'],   a list of derivatives of elements in T, maybe [];
#             p,   a normal polynomial in \bC(x, t1, ..., t_{n-1})[t_n].
#             f,   a rational function in \bC(x, T);
# Output:  the derivative of the residue of f at p
############################################################################################# 
DifferentiateResidue := proc(x, T, dT, f, p)
   local r, n, s;
   r := LocalResidue(x, T, dT, f, p);
   n := nops(T);
   if n = 0 then
      return 0;
   end if;
   s := DField:-AlgebraicDerivative(x, [op(1..n-1, T)], [op(1..n-1, dT)], T[n], p, r);
   return s;
end proc:

###########################################################################################
# Name: LocalResidue
# Calling sequence: LocalResidue(x, T, dT, f, p)
# Input:   x,    a variable of the base field C(x);
#             T = [t1, t2, .., tn],    a list of indeterminates over the base field, maybe [];
#             dT = [t1', t2', .., tn'],   a list of derivatives of elements in T, maybe [];
#             p,   a normal polynomial in \bC(x, t1, ..., t_{n-1})[t_n].
#             f,   a tn-element in \bC(x, T) or an x-simple function if T = [];
# Output:  the residue of f at p
############################################################################################# 
LocalResidue := proc(x, T, dT, f, p)
  local a, b, n, t, r, q, u;
  (a, b) := numer(f), denom(f);
  n := nops(T);
  if n = 0 then
     t := x;
  else
     t := T[n];
  end if;
  r := rem(b, p, t, 'q');
  if r <> 0 then
     return 0;
  end if;
  gcdex(q*DField:-Derivative(x, T, dT, p), p, t, 'u');
  return rem(a*u, p, t);
end proc: 

################################################################################################
# Name:  ConstantCoefficient
# Calling sequence:  ConstantCoefficient(x, T, dT, R, _Z)
# Input:   x,    a variable of the base field C(x);
#          T = [t1, t2, .., tn],    a list of indeterminates over the base field, T<>[];
#          dT = [t1', t2', .., tn'],   a list of derivatives of elements in T, maybe [];
#          R,   a nonzero simple function in C(x, T) in matryoshka form;
#          _Z, a formal variable
# Output:   C, a list of n constants,
#                lt, a logarithmic derivative
#                    such that all the residues of R - c[1]*dT[1] - ... - c[b]*dT[n] are constants and lt is the log part of R[n+1;
#                false. if there exist no such constants            
#################################################################################################

ConstantCoefficient  := proc(x, T, dT, R, _Z)
   local n, A, M, v, i, j, r, N, sols, s, S, C, lt;
   n := nops(T);
   lt := 0; 
   if R[n+1] <> 0 then
      lt := LogPart:-CompleteLogarithmicPart(x, T, dT, R[n+1], _Z); 
      if lt = 'false' then
         return false
      end if;
   end if; 
   (M, v) := Matrix(1, n), Matrix(1, 1);
   A := DField:-AssociatedMatrix(T, dT);
   for i from 1 to n-1 do
        r := R[i+1];
        N := AlgRaab(x, [op(1..i, T)], [op(1..i, dT)], r, LinearAlgebra:-Row(A, i+1)) ;
        M := MTM:-vertcat(M,  N[3]);
        v  := MTM:-vertcat(v, N[4]);
   end do;
   try
     sols := LinearAlgebra:-LinearSolve(LinearAlgebra:-DeleteRow(M, 1),  LinearAlgebra:-DeleteRow(v, 1), free = 's');
   catch "inconsistent system":
      return(false);
  end try;
  S := {seq(s[j,1]=0,  j=1..n)};
  C := [seq(subs(S, sols[j,1]),  j=1..n)]; 
  return C, lt;
end proc: 
   


end module:
